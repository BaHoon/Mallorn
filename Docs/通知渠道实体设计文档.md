# 通知渠道实体设计文档

## 概述

本文档描述了校园交易系统中新增的两个通知渠道实体：`SignalRNotification` 和 `EmailNotification`。这两个实体扩展了原有的通知系统，提供了具体的发送渠道管理功能。

## 实体关系

```
Notification (基础通知)
    ├── SignalRNotification (SignalR发送记录)
    └── EmailNotification (邮件发送记录)
```

### 关系说明

- **Notification → SignalRNotification**: 一对多关系，一个通知可以有多个SignalR发送记录
- **Notification → EmailNotification**: 一对多关系，一个通知可以有多个邮件发送记录
- **EmailNotification的特殊性**: 邮件通知支持两种类型：
  - `通知类型`: 必须关联Notification实体
  - `验证码类型`: 可以不关联Notification实体（独立的验证码邮件）

## 实体详细说明

### 1. SignalRNotification（SignalR通知发送）

#### 主要功能
- 管理通过SignalR发送的实时通知
- 支持单播（指定ConnectionId）和群播（指定GroupName）
- 提供重试机制和错误处理

#### 关键字段
- `SignalRNotificationId`: 主键，自增ID
- `NotificationId`: 外键，关联基础通知（必填）
- `ConnectionId`: SignalR连接ID（用于单播）
- `GroupName`: 用户组名称（用于群播）
- `SendStatus`: 发送状态（待发送/成功/失败）
- `RetryCount`: 重试次数
- `ErrorMessage`: 错误信息

#### 使用场景
- 实时订单状态更新
- 即时聊天消息
- 系统重要通知推送

### 2. EmailNotification（邮件通知发送）

#### 主要功能
- 管理所有邮件发送记录
- 支持两种邮件类型：通知邮件和验证码邮件
- 提供丰富的重试和错误处理机制

#### 关键字段
- `EmailNotificationId`: 主键，自增ID
- `EmailType`: 邮件类型（"通知"/"验证码"）
- `NotificationId`: 外键，关联基础通知（验证码类型时可为空）
- `RecipientEmail`: 收件人邮箱
- `Subject`: 邮件主题
- `Content`: 邮件内容（HTML格式）
- `VerificationCode`: 验证码（仅验证码类型使用）
- `CodeExpiresAt`: 验证码过期时间
- `SendStatus`: 发送状态

#### 邮件类型说明

##### 通知类型邮件
- 必须关联 `Notification` 实体
- 用于发送各种业务通知
- 示例：订单确认、交易完成、评价提醒等

##### 验证码类型邮件
- 可以不关联 `Notification` 实体
- 用于发送验证码
- 包含验证码和过期时间字段
- 示例：注册验证、密码重置、邮箱验证等

## 数据库部署

### 初始化脚本集成

新的通知渠道表已经集成到主数据库初始化脚本中：

**文件位置**: `Database/init-oracle.sql`

新增内容包括：
- **第20节**: SignalR通知表 (signalr_notifications)
- **第21节**: 邮件通知表 (email_notifications)
- **索引创建**: 针对新表的性能优化索引
- **表注释**: 详细的字段说明

### 部署方式

直接运行完整的初始化脚本即可：

```bash
# 在Oracle中执行
@Database/init-oracle.sql
```

这将创建所有表，包括新增的通知渠道表，无需额外的迁移脚本。

## 数据库设计

### 表结构

#### SIGNALR_NOTIFICATIONS
```sql
CREATE TABLE SIGNALR_NOTIFICATIONS (
    SIGNALR_NOTIFICATION_ID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    NOTIFICATION_ID NUMBER NOT NULL,
    CONNECTION_ID VARCHAR2(100),
    GROUP_NAME VARCHAR2(50),
    SEND_STATUS VARCHAR2(20) DEFAULT '待发送' NOT NULL,
    RETRY_COUNT NUMBER DEFAULT 0 NOT NULL,
    LAST_ATTEMPT_TIME TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
    CREATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
    SENT_AT TIMESTAMP,
    ERROR_MESSAGE VARCHAR2(500)
);
```

#### EMAIL_NOTIFICATIONS
```sql
CREATE TABLE EMAIL_NOTIFICATIONS (
    EMAIL_NOTIFICATION_ID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    EMAIL_TYPE VARCHAR2(20) NOT NULL,
    NOTIFICATION_ID NUMBER,
    RECIPIENT_EMAIL VARCHAR2(100) NOT NULL,
    SUBJECT VARCHAR2(200) NOT NULL,
    CONTENT CLOB NOT NULL,
    VERIFICATION_CODE VARCHAR2(10),
    CODE_EXPIRES_AT TIMESTAMP,
    SEND_STATUS VARCHAR2(20) DEFAULT '待发送' NOT NULL,
    RETRY_COUNT NUMBER DEFAULT 0 NOT NULL,
    LAST_ATTEMPT_TIME TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
    CREATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
    SENT_AT TIMESTAMP,
    ERROR_MESSAGE VARCHAR2(500)
);
```

### 约束和索引

#### 检查约束
- 发送状态只能是：待发送、成功、失败
- 邮件类型只能是：通知、验证码
- 重试次数必须 >= 0

#### 外键约束
- SignalR通知：级联删除（删除通知时同时删除SignalR发送记录）
- 邮件通知：置空删除（删除通知时邮件记录的通知ID置空）

#### 索引优化
- 发送状态索引（用于查询待发送记录）
- 创建时间索引（用于时间范围查询）
- 邮件地址索引（用于查询用户邮件记录）
- 验证码索引（用于验证码查询）

## 使用示例

### 1. 创建SignalR通知
```csharp
var signalRNotification = new SignalRNotification
{
    NotificationId = notification.NotificationId,
    ConnectionId = "connection-12345", // 或者设置GroupName进行群发
    SendStatus = SignalRNotification.SendStatuses.Pending,
    CreatedAt = DateTime.UtcNow
};
```

### 2. 创建通知类型邮件
```csharp
var emailNotification = new EmailNotification
{
    EmailType = EmailNotification.EmailTypes.Notification,
    NotificationId = notification.NotificationId,
    RecipientEmail = "user@example.com",
    Subject = "订单状态更新",
    Content = "<html><body>您的订单已发货</body></html>",
    SendStatus = EmailNotification.SendStatuses.Pending
};
```

### 3. 创建验证码邮件
```csharp
var verificationEmail = new EmailNotification
{
    EmailType = EmailNotification.EmailTypes.VerificationCode,
    NotificationId = null, // 验证码邮件可以不关联通知
    RecipientEmail = "newuser@example.com",
    Subject = "邮箱验证码",
    Content = $"<html><body>验证码：{code}</body></html>",
    VerificationCode = "123456",
    CodeExpiresAt = DateTime.UtcNow.AddMinutes(10),
    SendStatus = EmailNotification.SendStatuses.Pending
};
```

### 4. SQL操作示例

#### 插入SignalR通知记录
```sql
INSERT INTO signalr_notifications (
    notification_id,
    connection_id,
    group_name,
    send_status,
    retry_count,
    last_attempt_time,
    created_at
) VALUES (
    1, -- 假设存在通知ID为1的记录
    'connection-12345',
    'user-group-1',
    '待发送',
    0,
    CURRENT_TIMESTAMP,
    CURRENT_TIMESTAMP
);
```

#### 插入通知类型邮件记录
```sql
INSERT INTO email_notifications (
    email_type,
    notification_id,
    recipient_email,
    subject,
    content,
    send_status,
    retry_count,
    last_attempt_time,
    created_at
) VALUES (
    '通知',
    1, -- 假设存在通知ID为1的记录
    'user@example.com',
    '【校园交易系统】新订单通知',
    '<html><body><h1>您有新的订单</h1><p>请及时查看和处理。</p></body></html>',
    '待发送',
    0,
    CURRENT_TIMESTAMP,
    CURRENT_TIMESTAMP
);
```

#### 插入验证码邮件记录
```sql
INSERT INTO email_notifications (
    email_type,
    notification_id, -- 验证码类型时可为空
    recipient_email,
    subject,
    content,
    verification_code,
    code_expires_at,
    send_status,
    retry_count,
    last_attempt_time,
    created_at
) VALUES (
    '验证码',
    NULL, -- 验证码邮件不关联通知
    'new-user@example.com',
    '【校园交易系统】邮箱验证码',
    '<html><body><h1>邮箱验证码</h1><p>您的验证码是：<strong>123456</strong></p><p>该验证码将在10分钟后过期。</p></body></html>',
    '123456',
    CURRENT_TIMESTAMP + INTERVAL '10' MINUTE, -- 10分钟后过期
    '待发送',
    0,
    CURRENT_TIMESTAMP,
    CURRENT_TIMESTAMP
);
```

#### 查询示例
```sql
-- 查询待发送的SignalR通知
SELECT sn.*, n.template_id, n.recipient_id 
FROM signalr_notifications sn
JOIN notifications n ON sn.notification_id = n.notification_id
WHERE sn.send_status = '待发送'
ORDER BY sn.created_at;

-- 查询待发送的邮件通知
SELECT * FROM email_notifications 
WHERE send_status = '待发送'
ORDER BY created_at;

-- 查询失败需要重试的邮件
SELECT * FROM email_notifications 
WHERE send_status = '失败' 
  AND retry_count < 5
ORDER BY last_attempt_time;

-- 查询验证码邮件
SELECT * FROM email_notifications 
WHERE email_type = '验证码'
  AND code_expires_at > CURRENT_TIMESTAMP
ORDER BY created_at DESC;
```

## 重试机制

### 配置参数
- **SignalR**: 最大重试3次，间隔1分钟
- **邮件**: 最大重试5次，间隔5分钟

### 重试逻辑
1. 发送失败时，状态更新为"失败"
2. 重试次数+1，记录错误信息
3. 达到最大重试次数后不再重试
4. 后台服务定期扫描待重试的记录

## 最佳实践

### 1. 发送策略
- 优先使用SignalR进行实时通知
- 重要通知同时发送邮件作为备份
- 验证码等安全相关操作仅使用邮件

### 2. 性能优化
- 批量处理待发送记录
- 使用队列系统异步发送
- 定期清理过期的发送记录

### 3. 监控和告警
- 监控发送成功率
- 设置重试次数告警
- 记录详细的错误日志

## 注意事项

1. **邮件类型区分**: 注意区分通知邮件和验证码邮件的不同处理逻辑
2. **外键关系**: 验证码邮件的NotificationId可以为空
3. **过期处理**: 验证码邮件需要检查过期时间
4. **重试限制**: 避免无限重试，设置合理的重试上限
5. **数据清理**: 定期清理过期和已发送的记录，避免数据库膨胀
